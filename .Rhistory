results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
load("/wehisan/home/allstaff/m/mangiola.s/PhD/deconvolution/test_ARMET/myTest_TME_first_run_pure_populations_TME/epi_endo/input.RData")
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
?plan
library(ARMET)
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
?multiprocess
future:::multiprocess
library(ARMET)
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
?plan
?registerDoFuture
?dopar
doFuture:::plan(future:::multiprocess)
?v
?Filter
?melt
?ggplot
?DGEList
?lmFit
?top_de
?is_tibble
?bind_rows
?gather
?group_by
?summarise
?makeCluster
?colMedians
?left_join
?traceplot
?gsub
?rowSums
?calcNormFactors
?rnaseq_norm.calcNormFactor
?normalizeBetweenArrays
?cast
?aggregate
?dopar
?%dopar%
?summarise
?spread
?geom_abline
?read.ini
library(ARMET)
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
library(ARMET)
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
?cpm
library(ARMET)
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
library(ARMET)
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
library(ARMET)
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
?aes
?geom_text_repel
?element_blank
library(ARMET)
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
Q
library(ARMET)
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
library(ARMET)
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
?by
library(ARMET)
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
library(ARMET)
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
?rbind.fill
library(ARMET)
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
?plyr:::rbind.fill
library(ARMET)
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
Q
library(ARMET)
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
?bind_cols
library(ARMET)
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
Q
library(ARMET)
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
results$proportions
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
library(ARMET)
load("/wehisan/home/allstaff/m/mangiola.s/PhD/deconvolution/test_ARMET/myTest_TME_first_run_pure_populations_TME/epi_endo/input.RData")
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
ref.obj =   node_to_balanced_sampling(my_tree, ct, ref)
ref =       cbind(do.call("cbind", lapply(ref.obj$ct_main, function(ro) ro$df)))
markers =   unique(unlist(lapply(ref.obj$ct_main, function(ro) get_genes(node_from_name(my_tree, ro$name), recursive = F))))
ref.cell_types = factor(colnames(ref))
order_cell_types = levels(ref.cell_types)
if(any(!markers%in%rownames(mix)))
warning(sprintf("ARMET: The following markers were not present into the mixture dataset: %s Please reconsider the filtering process.\n", paste(markers[!markers%in%rownames(mix)])))
markers =                           markers[markers%in%rownames(ref) & markers%in%rownames(mix)]
mix =                               mix[markers,, drop=FALSE]
ref =                               ref[markers,, drop=FALSE]
ref.mean =                          get_mean_signature(ref)
ref.mean =                          ref.mean[,order_cell_types]
e.obj =                             prepare_input(ref, order_cell_types, markers)
#/
#|--------------------------------------------------------------------------
#| Background
#|--------------------------------------------------------------------------
#|
#| If down the my_tree compile the background\
#\
h = rev(rev(get_hierarchy(my_tree, ct))[-1])
bg_trees = divide_trees_proportion_across_many_trees(bg_tree)
bg_trees = lapply(bg_trees, add_absolute_proportions_to_tree)
#
# lapply(names(bg_trees), function(n) get_proportions_array(bg_trees[n], n))
#
# get_node_label_level_specfic(bg_trees[[1]], label = "absolute_proportion", recursive = T, level= 0, start_level = 0, stop_level = 0)
#
if(length(h) > 0) {
beta_bg = t(as.data.frame(lapply(bg_trees, get_last_existing_leaves_with_annotation)))
bg = cbind(do.call("cbind", lapply(ref.obj$ct_background, function(ro) ro$df)))
bg = bg[markers,]
} else {
bg = matrix(rep(0, length(markers)))
rownames(bg) = markers
colnames(bg) = "nn"
beta_bg = data.frame(rep(1, ncol(mix)), rep(0, ncol(mix)))
colnames(beta_bg) = c(ct, "bg")
}
p_target = t(beta_bg[,ct, drop=FALSE])
beta_bg = as.matrix(beta_bg[,!colnames(beta_bg)%in%ct])
x_bg = get_mean_signature(bg)
bg.obj = prepare_input(bg, levels(factor(colnames(bg))), markers)
if(ncol(beta_bg)>1) beta_bg = beta_bg[,colnames(x_bg)]
y_hat_background = as.matrix(beta_bg) %*% t(x_bg)
rownames(y_hat_background) = colnames(mix)
# balance the evidences
e_map_matrix_dim = table(e.obj$e$ct_num)
e_map_matrix_norm = median(e_map_matrix_dim)/e_map_matrix_dim
e_i_matrix = do.call(plyr:::rbind.fill, lapply(unique(sort(e.obj$e$ct_num)), function(ct) data.frame(t(data.frame(rownames(e.obj$e[e.obj$e$ct_num==ct,] ))))))
e_i_matrix = apply(e_i_matrix, 2, function(mc) {
x = as.numeric(as.character(mc))
x[is.na(x)] = 0
x
})
# if design is NULL
my_design = NULL
my_local_design = if(is.null(my_design)) matrix(rep(1, ncol(mix)), ncol=1) else my_design
#/
#|--------------------------------------------------------------------------
#|--------------------------------------------------------------------------
#\
# Create input object for the model
model.in = list(
G =                               length(markers),
S =                               ncol(mix),
P =                               length(unique(e.obj$e$ct_num)),
R =                               ncol(my_local_design),
y =                               t(mix), # - mean(exp(t(mix)))) / sd(exp(t(mix))),
X =                               my_local_design,
x =                               ref.mean,
y_hat_background =                y_hat_background,
p_target =                        p_target,
theta =                           theta,
is_mix_microarray =               as.numeric(is_mix_microarray),
# For full Bayesian
# Main node
E =                               nrow(e.obj$e),
E_MU =                            nrow(e.obj$e_mu),
map_e_genes =                     e.obj$e$gene_num,
map_e_ct =                        e.obj$e$ct_num,
map_e_to_mu =                     e.obj$e$map_to_mu,
e_ =                              e.obj$e$value,
map_e_mu_gene =                   e.obj$e_mu$gene_num,
map_e_mu_ct =                     e.obj$e_mu$ct_num,
e_i_matrix =                      e_i_matrix,
e_map_matrix_dim =                e_map_matrix_dim,
e_map_matrix_norm =               e_map_matrix_norm,
# Background
B =                               nrow(bg.obj$e),
B_MU =                            nrow(bg.obj$e_mu),
Q =                               length(unique(bg.obj$e$ct_num)),
map_bg_genes =                    bg.obj$e$gene_num,
map_bg_ct =                       bg.obj$e$ct_num,
map_bg_to_mu =                    bg.obj$e$map_to_mu,
b =                               bg.obj$e$value,
map_bg_mu_gene =                  bg.obj$e_mu$gene_num,
map_bg_mu_ct =                    bg.obj$e_mu$ct_num,
beta_bg =                         beta_bg
)
print(sprintf("%s/%s_model_in.RData", output_dir, ct))
#save(model.in, file=sprintf("%s/%s_model_in.RData", output_dir, ct))
# Choose model
model = if(fully_bayesian) stanmodels$ARMET_tc_recursive else stanmodels$ARMET_tcFix_recursive
# Run model
fit =
rstan::sampling(
model,
data=                             model.in,
iter=                             1000 ,
control =                         list(adapt_delta = 0.99, stepsize = 0.01, max_treedepth =15),
cores=4
)
ref.obj =   node_to_balanced_sampling(my_tree, ct, ref)
obj.in
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
my_tree
ref.obj =   node_to_balanced_sampling(my_tree, ct, ref)
ref =       cbind(do.call("cbind", lapply(ref.obj$ct_main, function(ro) ro$df)))
markers =   unique(unlist(lapply(ref.obj$ct_main, function(ro) get_genes(node_from_name(my_tree, ro$name), recursive = F))))
ref.cell_types = factor(colnames(ref))
order_cell_types = levels(ref.cell_types)
any(!markers%in%rownames(mix))
markers =                           markers[markers%in%rownames(ref) & markers%in%rownames(mix)]
mix =                               mix[markers,, drop=FALSE]
ref =                               ref[markers,, drop=FALSE]
ref.mean =                          get_mean_signature(ref)
ref.mean =                          ref.mean[,order_cell_types]
e.obj =                             prepare_input(ref, order_cell_types, markers)
h = rev(rev(get_hierarchy(my_tree, ct))[-1])
bg_trees = divide_trees_proportion_across_many_trees(bg_tree)
bg_trees = lapply(bg_trees, add_absolute_proportions_to_tree)
bg_trees
length(h) > 0
bg = matrix(rep(0, length(markers)))
rownames(bg) = markers
colnames(bg) = "nn"
beta_bg = data.frame(rep(1, ncol(mix)), rep(0, ncol(mix)))
colnames(beta_bg) = c(ct, "bg")
beta_bg
p_target = t(beta_bg[,ct, drop=FALSE])
beta_bg = as.matrix(beta_bg[,!colnames(beta_bg)%in%ct])
x_bg = get_mean_signature(bg)
bg.obj = prepare_input(bg, levels(factor(colnames(bg))), markers)
if(ncol(beta_bg)>1) beta_bg = beta_bg[,colnames(x_bg)]
beta_bg
y_hat_background = as.matrix(beta_bg) %*% t(x_bg)
rownames(y_hat_background) = colnames(mix)
# balance the evidences
e_map_matrix_dim = table(e.obj$e$ct_num)
e_map_matrix_norm = median(e_map_matrix_dim)/e_map_matrix_dim
e_i_matrix = do.call(plyr:::rbind.fill, lapply(unique(sort(e.obj$e$ct_num)), function(ct) data.frame(t(data.frame(rownames(e.obj$e[e.obj$e$ct_num==ct,] ))))))
e_i_matrix = apply(e_i_matrix, 2, function(mc) {
x = as.numeric(as.character(mc))
x[is.na(x)] = 0
x
})
# if design is NULL
my_design = NULL
# if design is NULL
#my_design = NULL
my_local_design = if(is.null(my_design)) matrix(rep(1, ncol(mix)), ncol=1) else my_design
my_design
matrix(rep(1, ncol(mix)), ncol=1)
# Create input object for the model
model.in = list(
G =                               length(markers),
S =                               ncol(mix),
P =                               length(unique(e.obj$e$ct_num)),
R =                               ncol(my_local_design),
y =                               t(mix), # - mean(exp(t(mix)))) / sd(exp(t(mix))),
X =                               my_local_design,
x =                               ref.mean,
y_hat_background =                y_hat_background,
p_target =                        p_target,
theta =                           theta,
is_mix_microarray =               as.numeric(is_mix_microarray),
# For full Bayesian
# Main node
E =                               nrow(e.obj$e),
E_MU =                            nrow(e.obj$e_mu),
map_e_genes =                     e.obj$e$gene_num,
map_e_ct =                        e.obj$e$ct_num,
map_e_to_mu =                     e.obj$e$map_to_mu,
e_ =                              e.obj$e$value,
map_e_mu_gene =                   e.obj$e_mu$gene_num,
map_e_mu_ct =                     e.obj$e_mu$ct_num,
e_i_matrix =                      e_i_matrix,
e_map_matrix_dim =                e_map_matrix_dim,
e_map_matrix_norm =               e_map_matrix_norm,
# Background
B =                               nrow(bg.obj$e),
B_MU =                            nrow(bg.obj$e_mu),
Q =                               length(unique(bg.obj$e$ct_num)),
map_bg_genes =                    bg.obj$e$gene_num,
map_bg_ct =                       bg.obj$e$ct_num,
map_bg_to_mu =                    bg.obj$e$map_to_mu,
b =                               bg.obj$e$value,
map_bg_mu_gene =                  bg.obj$e_mu$gene_num,
map_bg_mu_ct =                    bg.obj$e_mu$ct_num,
beta_bg =                         beta_bg
)
print(sprintf("%s/%s_model_in.RData", output_dir, ct))
model = stanmodels$ARMET_tcFix_recursive
fully_bayesian
# Run model
fit =
rstan::sampling(
model,
data=                             model.in,
iter=                             1000 ,
control =                         list(adapt_delta = 0.99, stepsize = 0.01, max_treedepth =15),
cores=4
)
proportions =                       t(parse_summary_vector_in_2D(apply( as.matrix(fit, pars = "beta"), 2, mean)))
proportions_sd =                    t(parse_summary_vector_in_2D(apply( as.matrix(fit, pars = "beta"), 2, sd)))
proportions_2.5 =                   t(parse_summary_vector_in_2D(apply( as.matrix(fit, pars = "beta"), 2, quantile, 0.025)))
proportions_97.5 =                  t(parse_summary_vector_in_2D(apply( as.matrix(fit, pars = "beta"), 2, quantile, 0.975)))
rownames(proportions) = rownames(proportions_2.5) = rownames(proportions_97.5) = rownames(proportions_sd) =  colnames(mix)
colnames(proportions) =  colnames(proportions_2.5) = colnames(proportions_97.5) = colnames(proportions_sd) = order_cell_types
proportions
load("/wehisan/home/allstaff/m/mangiola.s/PhD/deconvolution/ARMET/ARMET_results_2018_02_06_14_51_02/TME_model_in.RData")
# Run model
fit =
rstan::sampling(
model,
data=                             model.in,
iter=                             1000 ,
control =                         list(adapt_delta = 0.99, stepsize = 0.01, max_treedepth =15),
cores=4
)
proportions =                       t(parse_summary_vector_in_2D(apply( as.matrix(fit, pars = "beta"), 2, mean)))
proportions_sd =                    t(parse_summary_vector_in_2D(apply( as.matrix(fit, pars = "beta"), 2, sd)))
proportions_2.5 =                   t(parse_summary_vector_in_2D(apply( as.matrix(fit, pars = "beta"), 2, quantile, 0.025)))
proportions_97.5 =                  t(parse_summary_vector_in_2D(apply( as.matrix(fit, pars = "beta"), 2, quantile, 0.975)))
rownames(proportions) = rownames(proportions_2.5) = rownames(proportions_97.5) = rownames(proportions_sd) =  colnames(mix)
colnames(proportions) =  colnames(proportions_2.5) = colnames(proportions_97.5) = colnames(proportions_sd) = order_cell_types
proportions
model.in.good=model.in
# Create input object for the model
model.in = list(
G =                               length(markers),
S =                               ncol(mix),
P =                               length(unique(e.obj$e$ct_num)),
R =                               ncol(my_local_design),
y =                               t(mix), # - mean(exp(t(mix)))) / sd(exp(t(mix))),
X =                               my_local_design,
x =                               ref.mean,
y_hat_background =                y_hat_background,
p_target =                        p_target,
theta =                           theta,
is_mix_microarray =               as.numeric(is_mix_microarray),
# For full Bayesian
# Main node
E =                               nrow(e.obj$e),
E_MU =                            nrow(e.obj$e_mu),
map_e_genes =                     e.obj$e$gene_num,
map_e_ct =                        e.obj$e$ct_num,
map_e_to_mu =                     e.obj$e$map_to_mu,
e_ =                              e.obj$e$value,
map_e_mu_gene =                   e.obj$e_mu$gene_num,
map_e_mu_ct =                     e.obj$e_mu$ct_num,
e_i_matrix =                      e_i_matrix,
e_map_matrix_dim =                e_map_matrix_dim,
e_map_matrix_norm =               e_map_matrix_norm,
# Background
B =                               nrow(bg.obj$e),
B_MU =                            nrow(bg.obj$e_mu),
Q =                               length(unique(bg.obj$e$ct_num)),
map_bg_genes =                    bg.obj$e$gene_num,
map_bg_ct =                       bg.obj$e$ct_num,
map_bg_to_mu =                    bg.obj$e$map_to_mu,
b =                               bg.obj$e$value,
map_bg_mu_gene =                  bg.obj$e_mu$gene_num,
map_bg_mu_ct =                    bg.obj$e_mu$ct_num,
beta_bg =                         beta_bg
)
head(model.in$x)
head(model.in.good$x)
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
dim(ref)
library(ARMET)
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
data(ref_RNAseq)
ref_RNAseq
dim(ref)
ref = as.matrix(read.csv("~/PhD/deconvolution/ARMET_dev/ARMET_TME_signature_df_RNAseq.csv", header=T, row.names=1))
colnames(ref) = as.vector(sapply(colnames(ref), function(cn) strsplit(cn, ".", fixed=T)[[1]][1]))
getwd()
save(ref, file="data/ref_RNAseq.rda")
library(ARMET)
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
load("/wehisan/home/allstaff/m/mangiola.s/PhD/deconvolution/test_ARMET/myTest_TME_first_run_pure_populations_TME/epi_endo/input.RData")
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
di(ref)
dim(ref)
library(ARMET)
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
results$proportions
library(ARMET)
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
head(model.in$x)
getwd()
load("/wehisan/home/allstaff/m/mangiola.s/PhD/deconvolution/ARMET/ARMET_results_2018_02_06_14_51_02/TME_model_in.RData")
head(model.in$x)
dim(model.in$x)
# Create input object for the model
model.in = list(
G =                               length(markers),
S =                               ncol(mix),
P =                               length(unique(e.obj$e$ct_num)),
R =                               ncol(my_local_design),
y =                               t(mix), # - mean(exp(t(mix)))) / sd(exp(t(mix))),
X =                               my_local_design,
x =                               ref.mean,
y_hat_background =                y_hat_background,
p_target =                        p_target,
theta =                           theta,
is_mix_microarray =               as.numeric(is_mix_microarray),
# For full Bayesian
# Main node
E =                               nrow(e.obj$e),
E_MU =                            nrow(e.obj$e_mu),
map_e_genes =                     e.obj$e$gene_num,
map_e_ct =                        e.obj$e$ct_num,
map_e_to_mu =                     e.obj$e$map_to_mu,
e_ =                              e.obj$e$value,
map_e_mu_gene =                   e.obj$e_mu$gene_num,
map_e_mu_ct =                     e.obj$e_mu$ct_num,
e_i_matrix =                      e_i_matrix,
e_map_matrix_dim =                e_map_matrix_dim,
e_map_matrix_norm =               e_map_matrix_norm,
# Background
B =                               nrow(bg.obj$e),
B_MU =                            nrow(bg.obj$e_mu),
Q =                               length(unique(bg.obj$e$ct_num)),
map_bg_genes =                    bg.obj$e$gene_num,
map_bg_ct =                       bg.obj$e$ct_num,
map_bg_to_mu =                    bg.obj$e$map_to_mu,
b =                               bg.obj$e$value,
map_bg_mu_gene =                  bg.obj$e_mu$gene_num,
map_bg_mu_ct =                    bg.obj$e_mu$ct_num,
beta_bg =                         beta_bg
)
dim(model.in$x)
library(ARMET)
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
load("/wehisan/home/allstaff/m/mangiola.s/PhD/deconvolution/test_ARMET/myTest_TME_first_run_pure_populations_TME/epi_endo/input.RData")
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
dim(ref)
load("/wehisan/home/allstaff/m/mangiola.s/PhD/deconvolution/ARMET/ARMET_results_2018_02_06_14_51_02/ARMET_tc_input.RData")
dim(ref)
load("data/ref_RNAseq.rda")
dim(ref)
data(ref_RNAseq)
rm(ref)
data(ref_RNAseq)
load(ref_RNAseq)
load("data/ref_RNAseq.rda")
dim(ref)
load("/wehisan/home/allstaff/m/mangiola.s/PhD/deconvolution/test_ARMET/myTest_TME_first_run_pure_populations_TME/epi_endo/input.RData")
library(ARMET)
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
dim(ref)
model
model =  stanmodels$ARMET_tcFix_recursive
# Run model
fit =
rstan::sampling(
model,
data=                             model.in,
iter=                             1000 ,
control =                         list(adapt_delta = 0.99, stepsize = 0.01, max_treedepth =15),
cores=4
)
proportions =                       t(parse_summary_vector_in_2D(apply( as.matrix(fit, pars = "beta"), 2, mean)))
proportions_sd =                    t(parse_summary_vector_in_2D(apply( as.matrix(fit, pars = "beta"), 2, sd)))
proportions_2.5 =                   t(parse_summary_vector_in_2D(apply( as.matrix(fit, pars = "beta"), 2, quantile, 0.025)))
proportions_97.5 =                  t(parse_summary_vector_in_2D(apply( as.matrix(fit, pars = "beta"), 2, quantile, 0.975)))
rownames(proportions) = rownames(proportions_2.5) = rownames(proportions_97.5) = rownames(proportions_sd) =  colnames(mix)
colnames(proportions) =  colnames(proportions_2.5) = colnames(proportions_97.5) = colnames(proportions_sd) = order_cell_types
proportions
traceplot(fit)
library(ARMET)
load("/wehisan/home/allstaff/m/mangiola.s/PhD/deconvolution/test_ARMET/myTest_TME_first_run_pure_populations_TME/epi_endo/input.RData")
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
results$proportions
library(ARMET)
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
head(model.in$x)
dim(model.in$x)
getwd()
tree = read_json("/wehisan/home/allstaff/m/mangiola.s/PhD/deconvolution/ARMET_dev/ARMET_TME_tree_RNAseq.json")
# Create trees
library(jsonlite)
tree = read_json("/wehisan/home/allstaff/m/mangiola.s/PhD/deconvolution/ARMET_dev/ARMET_TME_tree_RNAseq.json")
save(tree, file="data/tree_json.rda")
library(jsonlite)
tree = read_json("/wehisan/home/allstaff/m/mangiola.s/PhD/deconvolution/ARMET_dev/ARMET_TME_tree_RNAseq.json")
save(tree, file="data/tree_json.rda")
library(ARMET)
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
dim(model.in$x)
model = stanmodels$ARMET_tcFix_recursive
# Run model
fit =
rstan::sampling(
model,
data=                             model.in,
iter=                             1000 ,
control =                         list(adapt_delta = 0.99, stepsize = 0.01, max_treedepth =15),
cores=4
)
proportions =                       t(parse_summary_vector_in_2D(apply( as.matrix(fit, pars = "beta"), 2, mean)))
proportions_sd =                    t(parse_summary_vector_in_2D(apply( as.matrix(fit, pars = "beta"), 2, sd)))
proportions_2.5 =                   t(parse_summary_vector_in_2D(apply( as.matrix(fit, pars = "beta"), 2, quantile, 0.025)))
proportions_97.5 =                  t(parse_summary_vector_in_2D(apply( as.matrix(fit, pars = "beta"), 2, quantile, 0.975)))
rownames(proportions) = rownames(proportions_2.5) = rownames(proportions_97.5) = rownames(proportions_sd) =  colnames(mix)
colnames(proportions) =  colnames(proportions_2.5) = colnames(proportions_97.5) = colnames(proportions_sd) = order_cell_types
proportions
library(ARMET)
results = ARMET_tc(mix[,2:3], cov_to_test = cov_to_test, observed_prop=prop)
results$proportions
